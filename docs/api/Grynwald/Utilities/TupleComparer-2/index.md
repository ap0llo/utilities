# TupleComparer\<T1, T2\> Class

**Namespace:** [Grynwald.Utilities](../index.md)

**Assembly:** Grynwald.Utilities

Implementation of IEqualityComparer\<T\> for tuples with two elements composed of comparers for the tuple's individual items.

```csharp
public class TupleComparer<T1, T2> : IEqualityComparer<ValueTuple<T1, T2>>
```

**Inheritance:** object → TupleComparer\<T1, T2\>

**Implements:** IEqualityComparer\<ValueTuple\<T1, T2\>\>

## Type Parameters

`T1`

The type of the tuple's first element.

`T2`

The type of the tuple's second element.

## Constructors

| Name                                                                                     | Description                                            |
| ---------------------------------------------------------------------------------------- | ------------------------------------------------------ |
| [TupleComparer(IEqualityComparer\<T1\>, IEqualityComparer\<T2\>)](constructors/index.md) | Initializes a new instance of TupleComparer\<T1, T2\>. |

## Methods

| Name                                                                    | Description |
| ----------------------------------------------------------------------- | ----------- |
| [Equals(ValueTuple\<T1, T2\>, ValueTuple\<T1, T2\>)](methods/Equals.md) |             |
| [GetHashCode(ValueTuple\<T1, T2\>)](methods/GetHashCode.md)             |             |

## Example

Using this class, comparers for ValueTuple\<T1, T2\> can easily be created by composing comparers for the tuple's individual elements.

```csharp
var myIntComparer = EqualityComparer<int>.Default;
var myStringComparer = StringComparer.OrdinalIgnoreCase;
var tupleComparer = new TupleComparer<int, string>(myIntComparer, myStringComparer);
var equal = tupleComparer.Equals((1, "foo"), (1, "FOO"));
Debug.Assert(equal == true);
```

## See Also

- [TupleComparer](../TupleComparer/index.md)
- [TupleComparer\<T1, T2, T3\>](../TupleComparer-3/index.md)

___

*Documentation generated by [MdDocs](https://github.com/ap0llo/mddocs)*
